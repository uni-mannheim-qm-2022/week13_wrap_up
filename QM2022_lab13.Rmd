---
title: "QM 2022 Week 13: Wrap Up"
author: "Oliver Rittmann & Domantas Undzėnas  & Lion Behrens"
date: "November 30 | December 1 | December 2, 2022"
output:
  html_document: 
    toc: yes
    number_sections: yes
    toc_float: yes
    highlight: tango
    css: css/lab.css
    keep_md: yes
    code_folding: show
    fig_width: 8
    fig_height: 4
    fig_caption: yes
  pdf_document:
    toc: yes
    keep_md: yes
header-includes:
- \usepackage{dcolumn}
bibliography: citations.bib # this adds a bibliography file from the repo
biblio-style: apsr # this selects the style 
editor_options: 
  chunk_output_type: inline
  markdown: 
    wrap: sentence
---

---

Today:

1.  Simulation, Simulation... Visualizing Interaction Effects in non-linear models
2.  Simulation, Simulation... A range of values in a count model
3.  Robustness checks
4.  Formatting and RMarkdown (Revision)

Goals for Today:

-   do simulations with non-linear & interactions over the range of values
-   think critically about the quantities of interest we produce
-   explore the commonly used robustness checks
-   review how to do citations and use chunk options in RMarkdown

---
```{r setup, message=FALSE, warning=FALSE, results='hide'}
# The first line sets an option for the final document that can be produced from
# the .Rmd file. Don't worry about it.
knitr::opts_chunk$set(echo = TRUE,
                      collapse = TRUE,
                      out.width="\\textwidth", # for larger figures 
                      attr.output = 'style="max-height: 200px"',
                      tidy = 'styler' # styles the code in the output
                      )

# The next bit is quite powerful and useful. 
# First you define which packages you need for your analysis and assign it to 
# the p_needed object. 
p_needed <-
  c("ggplot2", "viridis", "MASS", "optimx", "scales", "foreign", 
    "patchwork", "stargazer", "janitor")

# Now you check which packages are already installed on your computer.
# The function installed.packages() returns a vector with all the installed 
# packages.
packages <- rownames(installed.packages())
# Then you check which of the packages you need are not installed on your 
# computer yet. Essentially you compare the vector p_needed with the vector
# packages. The result of this comparison is assigned to p_to_install.
p_to_install <- p_needed[!(p_needed %in% packages)]
# If at least one element is in p_to_install you then install those missing
# packages.
if (length(p_to_install) > 0) {
  install.packages(p_to_install, repos = "http://cran.us.r-project.org")
}
# installation from a different source
if ("countreg" %in% p_to_install) {
  install.packages("countreg", repos = "http://R-Forge.R-project.org")
}
# Now that all packages are installed on the computer, you can load them for
# this project. Additionally the expression returns whether the packages were
# successfully loaded.
sapply(p_needed, require, character.only = TRUE)

# This is an option for stargazer tables
# It automatically adapts the output to html or latex,
# depending on whether we want a html or pdf file
stargazer_opt <- ifelse(knitr::is_latex_output(), "latex", "html")

# Don't worry about this part: it ensures that if the file is knitted to html,
# significance notes are depicted correctly
if (stargazer_opt == "html"){
  fargs <- formals(stargazer)
  fargs$notes.append = FALSE
  fargs$notes = c("<em>&#42;p&lt;0.1;&#42;&#42;p&lt;0.05;&#42;&#42;&#42;p&lt;0.01</em>")
  formals(stargazer) <- fargs
}

# only relevant for ggplot2 plotting
# setting a global ggplot theme for the entire document to avoid 
# setting this individually for each plot 
theme_set(theme_classic() + # start with classic theme 
  theme(
    plot.background = element_blank(),# remove all background 
    plot.title.position = "plot", # move the plot title start slightly 
    legend.position = "bottom" # by default, put legend on the bottom
  ))

set.seed(2022)
```



# 1. Simulation, Simulation... Visualizing Interaction Effects in non-linear models

Unfortunately, the intuition about interaction terms form linear models does not extend to non-linear models.

However, we have one really powerful tool in our toolbox that can help us to look at and interpret interactions in any model. Simulation!

As some of you had problems with the interaction effect in a logit model in Homework 9, we will look at an interaction in a logit model here.

The same logic applies to any other non-linear model.

---

For the last time, we will start with some fake data.

```{r}
# Population Size

n <- 100000

# True Parameters

beta0 <- -2
beta1 <- 0.3
beta2 <- 0.5
beta3 <- -0.2

# Independent Variables

X1 <- rnorm(n, 20, 10)
X2 <- rnorm(n, 1, 0.5)

# Our Systematic component

mu <- beta0 + beta1 * X1 + beta2 * X2 + beta3 * X1 * X2

# Now we generate p via the logit response function

p <- (exp(mu)) / (1 + exp(mu))


# As we observe only 0 or 1 we need to put p in a binomial distribution

Y <- rbinom(n, 1, p)

# That's our full population.

pop <- data.frame(Y, X1, X2)

# Let's work with a sample from our population

data <- pop[sample(1:10000, 1000),]


# Now we can run the model...

m1 <-
  glm(Y ~ X1 + X2 + X1 * X2,
      data = data,
      family = binomial(link = logit))

summary(m1)
```

So now we can't make sense of these coefficients... 

# To see what those coefficients mean, we use simulation.

## A. Simulate Parameters - Remember the Steps?

Steps for Simulating Parameters:

* 1. Get the coefficients from the regression (gamma.hat)
* 2. Get the variance-covariance matrix (V.hat)
* 3. Set up a multivariate normal distribution N(gamma.hat,V.hat)
* 4. Draw from the distribution nsim times

```{r}
gamma_hat <- coef(m1)
V_hat <- vcov(m1)

S <- mvrnorm(1000, gamma_hat, V_hat)
```


## B. Calculate Expected Values

Set up interesting scenarios. That's the important step here!

```{r}
X1_sim <- seq(min(X1), max(X1), length.out = 100)

X2_lo <- quantile(X2, 0.25)
X2_hi <- quantile(X2, 0.75)

scenario_X2lo <- cbind(1, X1_sim, X2_lo, X1_sim * X2_lo)
scenario_X2hi <- cbind(1, X1_sim, X2_hi, X1_sim * X2_hi)

Xbeta_lo <- S %*% t(scenario_X2lo)
Xbeta_hi <- S %*% t(scenario_X2hi)

dim(Xbeta_lo)
dim(Xbeta_hi)

# To get expected values for p, we need to plug in the Xbeta values into
# the response function to get simulatd probabilities

p_sim_lo <- (exp(Xbeta_lo)) / (1 + exp(Xbeta_lo))
p_sim_hi <- (exp(Xbeta_hi)) / (1 + exp(Xbeta_hi))

dim(p_sim_lo)
dim(p_sim_hi)


# Means and Quantiles

p_mean_lo <- apply(p_sim_lo, 2, mean)
p_qu_lo <- t(apply(p_sim_lo, 2, quantile, prob = c(0.025, 0.975)))

p_mean_hi <- apply(p_sim_hi, 2, mean)
p_qu_hi <- t(apply(p_sim_hi, 2, quantile, prob = c(0.025, 0.975)))

## C. Plot

plot(
  X1_sim,
  p_mean_lo,
  type = "n",
  ylim = c(0, 1),
  ylab = "Probability of Y",
  xlab = "X1",
  bty = "n",
  las = 1
)

polygon(
  c(rev(X1_sim), X1_sim),
  c(rev(p_qu_lo[, 2]), p_qu_lo[, 1]),
  col = adjustcolor("lightblue", alpha = 0.5),
  border = NA
)

polygon(
  c(rev(X1_sim), X1_sim),
  c(rev(p_qu_hi[, 2]), p_qu_hi[, 1]),
  col = adjustcolor("lightgray", alpha = 0.5),
  border = NA
)


lines(X1_sim, p_mean_lo, lwd = 1)
lines(X1_sim, p_qu_lo[, 1], lty = "dashed", col = "gray20")
lines(X1_sim, p_qu_lo[, 2], lty = "dashed", col = "gray20")


lines(X1_sim, p_mean_hi, lwd = 1)
lines(X1_sim, p_qu_hi[, 1], lty = "dashed", col = "gray20")
lines(X1_sim, p_qu_hi[, 2], lty = "dashed", col = "gray20")


# Add a "histogram" of actual X1-values.

axis(
  1,
  at = X1,
  col.ticks = "gray30",
  labels = FALSE,
  tck = 0.02
) 
```

How about looking at the first difference of the two scenarios directly?

```{r}
fd <- p_sim_lo - p_sim_hi

fd_mean <- apply(fd, 2, mean)

fd_qu <- t(apply(fd, 2, quantile, prob = c(0.025, 0.975)))



plot(
  X1_sim,
  fd_mean,
  type = "n",
  ylim = c(-1, 1),
  ylab = "Difference in predicted probabilities",
  xlab = "X1",
  bty = "n",
  las = 1
)

polygon(
  c(rev(X1_sim), X1_sim),
  c(rev(fd_qu[, 2]), fd_qu[, 1]),
  col = adjustcolor("lightblue", alpha = 0.5),
  border = NA
)

abline(h = 0)
lines(X1_sim, fd_mean, lwd = 1)
lines(X1_sim, fd_qu[, 1], lty = "dashed", col = "gray20")
lines(X1_sim, fd_qu[, 2], lty = "dashed", col = "gray20")


axis(
  1,
  at = X1,
  col.ticks = "gray30",
  labels = FALSE,
  tck = 0.02
) 
```

That looks funky (and not linear at all...).

# 2. Simulation, Simulation... A range of values in a count model

Let's simulate some more. We take another look at the data last week. We make our model 2 from last week slightly more interesting, by adding an interaction between regime type and the number of prior one-sided killings.

```{r}
dta <- read.dta("eck_rep.dta")
#  Some data preparation

dta$os_best[dta$os_best == 500000] <- NA # Rwanda

m2 <-
  glm.nb(
    os_best ~ intensity_dyad + auto + demo + govt + prior_os*auto + prior_os*demo,
    data = dta,
    control = glm.control(maxit = 200)
  )
summary(m2)
```


## A. Simulate Parameters - Remember the Steps?

Steps for Simulating Parameters (Estimation Uncertainty)
1. Get the coefficients from the regression (gamma.hat)
2. Get the variance-covariance matrix (V.hat)
3. Set up a multivariate normal distribution N(gamma.hat,V.hat)
4. Draw from the distribution nsim times


```{r}
nsim <- 1000

gamma_hat <- coef(m2)

V_hat <- vcov(m2)

S <- mvrnorm(nsim, gamma_hat, V_hat)
```


## B. Calculate Expected Values

Set up interesting scenarios.

Autocracies

```{r}
coef(m2)
prior_os_seq <-
  round(seq(min(dta$prior_os, na.rm = TRUE),
      quantile(dta$prior_os, 0.95, na.rm = T),
      length.out = 100), 0)

scenario1 <-
  cbind(
    1,
    median(dta$intensity_dyad, na.rm = TRUE),
    1,
    0,
    median(dta$govt, na.rm = TRUE),
    prior_os_seq,
    prior_os_seq,
    0
  ) 
```


Democracies

```{r}
scenario2 <- cbind(
  1,
  median(dta$intensity_dyad, na.rm = TRUE),
  0,
  1,
  median(dta$govt, na.rm = TRUE),
  prior_os_seq,
  0,
  prior_os_seq
)
```


Anocracies

```{r}
scenario3 <- cbind(
  1,
  median(dta$intensity_dyad, na.rm = TRUE),
  0,
  0,
  median(dta$govt, na.rm = TRUE),
  prior_os_seq,
  0,
  0
) 
```


```{r}
Xbeta1 <- S %*% t(scenario1)

Xbeta2 <- S %*% t(scenario2)

Xbeta3 <- S %*% t(scenario3)
```


To get expected values for lambda, we need to plug in the Xbeta values into the response function 

```{r}
lambda1 <- exp(Xbeta1)

lambda2 <- exp(Xbeta2)

lambda3 <- exp(Xbeta3)
```

Now we need an additional step: Plug the lambda and theta into the negative binomial distribution. And then we average over the fundamental uncertainty for expected values. Please have a look at the King et al. 2001 article from Week 7 again for further information. 

Get the theta.

```{r}
theta <- m2$theta

exp_auto <-
  matrix(sapply(lambda1, function(x)
    mean(rnbinom(1000, size = theta, mu = x))), nrow = 1000)

exp_demo <-
  matrix(sapply(lambda2, function(x)
    mean(rnbinom(1000, size = theta, mu = x))), nrow = 1000)

exp_ano <-
  matrix(sapply(lambda3, function(x)
    mean(rnbinom(1000, size = theta, mu = x))), nrow = 1000)
```


Summarize the results.

```{r}
median_auto <- apply(exp_auto, 2, median)
quants_auto <- t(apply(exp_auto, 2, quantile, c(0.025, 0.975)))

median_demo <- apply(exp_demo, 2, median)
quants_demo <- t(apply(exp_demo, 2, quantile, c(0.025, 0.975)))

median_ano <- apply(exp_ano, 2, median)
quants_ano <- t(apply(exp_ano, 2, quantile, c(0.025, 0.975)))
```

Plot it.

```{r}
plot(
  prior_os_seq,
  median_auto,
  type = "n",
  ylim = c(0, 1000),
  ylab = "Expected Number of one-sided Killings",
  xlab = "Prior one-sided Killings",
  bty = "n",
  las = 1
)

polygon(
  c(rev(prior_os_seq), prior_os_seq),
  c(rev(quants_auto[, 2]), quants_auto[, 1]),
  col = adjustcolor("lightblue", alpha = 0.2),
  border = NA
)

polygon(
  c(rev(prior_os_seq), prior_os_seq),
  c(rev(quants_demo[, 2]), quants_demo[, 1]),
  col = adjustcolor("lightgray", alpha = 0.2),
  border = NA
)

polygon(
  c(rev(prior_os_seq), prior_os_seq),
  c(rev(quants_ano[, 2]), quants_ano[, 1]),
  col = adjustcolor("maroon3", alpha = 0.2),
  border = NA
)

lines(prior_os_seq, median_auto, lwd = 2)
lines(prior_os_seq, quants_auto[, 1], lwd = 0.5, lty = "dashed", col = "lightblue")
lines(prior_os_seq, quants_auto[, 2], lwd = 0.5, lty = "dashed", col = "lightblue")

lines(prior_os_seq, median_demo, lwd = 2, lty = "dotted")
lines(prior_os_seq, quants_demo[, 1], lwd = 0.5, lty = "dashed", col = "lightgray")
lines(prior_os_seq, quants_demo[, 2], lwd = 0.5, lty = "dashed", col = "lightgray")


lines(prior_os_seq, median_ano, lwd = 2, lty = "dashed")
lines(prior_os_seq, quants_ano[, 1], lty = "dashed", col = "maroon3")
lines(prior_os_seq, quants_ano[, 2], lty = "dashed", col = "maroon3")


# Add a "histogram" of actual X1-values.

axis(
  1,
  at = dta$prior_os,
  col.ticks = "gray30",
  labels = FALSE,
  tck = 0.02
) 

legend(
  "topleft",
  legend = c(
    "Autocracy - median",
    "Autocracy - 95% CI",
    "Democracy - median",
    "Democracy - 95% CI",
    "Anocracy - median",
    "Anocracy - 95% CI"
  ),
  col = c(
    "black",
    adjustcolor("lightblue", alpha = 0.5),
    "black",
    adjustcolor("lightgray", alpha = 0.5),
    "black",
     adjustcolor("maroon3", alpha = 0.5)
  ),
  lty = c("solid", NA, "dotted", NA, "dashed", NA),
  lwd = c(2, NA, 2, NA, 2, NA),
  pch = c(NA, 15, NA, 15, NA, 15),
  pt.cex = 2,
  bty = "n"
)
```



# Robustness Checks

> "All models are wrong, but some are useful." -- George Box

We cannot specify our models perfectly and correctly since the data generation process and causal relationships are very complex.
Instead, when doing modeling, we make assumptions about DGP and select model specification based on these assumptions.
Having a reasonable baseline model with a reasonable set of covariates, our best attempt of optimizing the specification of the empirical model, is not where we should stop.
Once we have a good baseline model, we should try to see whether the results obtained by this model hold when we substitute the baseline model specification with plausible alternatives.
This is the practice of robustness testing.

In short, with robustness testing we analyze if the estimated effects of interest are sensitive to changes in model specifications.
Robustness tests can increase the validity of inferences.

## Population Definition and Sample Tests

A very common test is *outlier elimination*, where one essentially drops the outliers.
Keep in mind, however, that if the model is strongly misspecified, outlier tests are more likely to pick up the consequences of model misspecification than to detect true outliers (cases that are not part of the population), thereby making bias potentially worse.
We can try implementing this test for our model from before.
Following the approach in [@hilbe2009], we'll treat observations with so-called standardized deviance residuals (a generalization of $\hat\epsilon_i$ for GLMs) greater than 2 as potential outliers.

```{r basic-model, collapse=FALSE}
summary(m2)
# remove outliers 
m3 <- glm.nb(formula = os_best ~ intensity_dyad + auto + demo + govt + 
    prior_os, data = m2$model[!rstandard(m2) > 2,], control = glm.control(maxit = 200), 
    )
summary(m3)
```

One can also consider gradually *expanding the sample size* and moving away from what they consider to be the sample "for which the theoretical framework most directly applies", as @scheve2004a do in their analysis of whether economic integration increases worker insecurity in advanced economies.
Authors point out:

> Our core results are for a sample of private-sector, full-time, not-self-employed workers: the labor-market participants for which the theoretical framework most directly applies.
> Our FDI-insecurity correlation of interest maintained in estimates of key specifications using broader samples.

One more approach related to samples is a **placebo test**, i.e. selecting a sample for which the theory should not apply and the effects should not be found.
This is what @reuter2019 do when studying defections from the ruling party in an autocratic regime and showing that the effects are only found for the candidates in the ruling party and not other parties, as their theory argues.

## Concept Validity and Measurement Tests

Another commonly used approach is to use an **alternative operationalization** of your dependent or key independent variables.
For instance, @scheve2004a uses various measures of their dependent variable, Foreign Direct Investment exposure (they have a great robustness tests section).
Looking back at our @eck_hultman_2007 example, showing that your results do not depend on, for instance, the definition of democracy that we use, could be an example of such test.
For instance, if we are interested in the effect of regimes on one-sided killings, we would want to show that our results hold when we use the Polity score and the Democracy-Dictatorship measure [@cheibub2009] (although in this particular case since we require an intermediate category between autocracy and democracy, a dichotomous measure would not be appropriate).

If we keep working with the model from before, we can explore if the continuous measure of regime type produces similar results to the categorical one (yet this will not be the best test in this case):

```{r remove-outliers, fig.cap="**Expected number of one-sided killings over the Range of Polity2 score**. Simulation based on model 5, other variables set to average value in dataset. Segments depict 95\\% confidence intervals. Data from Eck \\& Hultman (2007)."}
# continuous Polity score instead of categories
# squared term for the inverse-U shape (democracy & autocracy have lower 
# killings than anocracy, the middle category)
m5 <-
  glm.nb(
    formula = os_best ~ intensity_dyad + polity2 + polity_sq + govt + prior_os,
    data = dta,
    control = glm.control(maxit = 200),
  )
S <- mvrnorm(1000, coef(m5), vcov(m5))
polity_seq <- -10:10
Xbeta <-
  S %*% t(cbind(1, 1, polity_seq, polity_seq ^ 2, 1, mean(dta$prior_os, na.rm = T)))
lambda <- exp(Xbeta)
quants <- t(apply(lambda, 2, quantile, c(0.025, 0.5, 0.975)))
plot(
  x = polity_seq,
  y = quants[, 2],
  type = "p",
  ylim = c(0, 80),
  pch = 19,
  las = 1, 
  ylab = "One-sided Killings",
  xlab = "Polity2 Score"
)
segments(x0 = polity_seq,
         y0 = quants[, 1],
         y1 = quants[, 3])
axis(1, at = c(-10, 10),
     labels = c("Least democratic", "Most democratic"), 
     padj = 1.2)

```

As we see, the relationship between the variables does not seem to be U-shaped, as @eck_hultman_2007 point out in the text.
We should note, however, that using a 21-point scale implies a strong assumption on the effect of a variable: implicitly, the operationalization assumes that changes from, say, -10 to -5 represent an equally strong move to a more democratic regime as a move from 5 to 10.
This is a very strong assumption to make and usually, it will be a more appropriate choice to avoid making such an assumption.
Hence, it would be a good test for robustness to use some aggregation of a continuous predictor of such kind.

We thus need to have a closer look at the values the authors used as thresholds.
If we are transforming Polity score into a categorical variable, we'd want to show that our results do not depend on the arbitrary cut-off point we used for distinguishing between democracy, anocracy, and autocracy.

```{r vary-cutoffs}
# check existing cutoffs 
table(dta$auto, dta$polity2)
table(dta$demo, dta$polity2)

coefs_matrix <- NULL
# we can select some theoretically sensible values for cutoffs
for (demo_cutoff in 3:8){
  for (auto_cutoff in -3:0){
    dta$demo1 <- ifelse(dta$polity2 > demo_cutoff, 1, 
                        ifelse(is.na(dta$polity2), NA, 0))
    dta$auto1 <- ifelse(dta$polity2 < auto_cutoff, 1, 
                        ifelse(is.na(dta$polity2), NA, 0))
  m <- glm.nb(
    formula = os_best ~ intensity_dyad + auto1 + demo1 + govt + prior_os,
    data = dta,
    control = glm.control(maxit = 200),
  )
  coefs <- c(auto_cutoff, demo_cutoff, coef(m))
  coefs_matrix <- rbind(coefs, coefs_matrix)
  }
}
summary(coefs_matrix[,"auto1"])
summary(coefs_matrix[,"demo1"])
```

For this particular model, it seems to be the case the estimates depend heavily on the cut-off points even if we look only at the signs of the estimates, hence questioning the robustness of findings from the main model.

Note, however, that should we select some meaningless cut-off points, we would expect it that the model estimates should not hold.
Such an approach could be treated as a **placebo test** for the model.

# Formatting and RMarkdown {.tabset}

For your data essay, you may choose to write the complete paper in RMarkdown (and this will be a very efficient option).
You will be able to both do all analyses and write up the text in the same program.
Here we will review the most relevant RMarkdown aspects when it comes to generating PDF output: YAML details, most commonly used chunk options, advice on tables and figures formatting, and doing citations.
But before we move to them, make sure that you had a look at the [Visual Editor interface](https://rstudio.github.io/visual-markdown-editing/), that makes formatting much easier in case, especially for tables and citations.
Rstudio's guide contains lots of aspects that can help you work more efficiently.

## YAML {.unnumbered}

Your standard YAML when creating a PDF will contain the title, author, date, and the output types:

``` {.yaml}
---
title: "Data Essay"
author: Anna Schmidt
date: December 7, 2022
output: pdf_document
---
```

You may want to add the table of contents, and `toc_depth` will define how many levels are depicted in TOC:

``` {.yaml}
output:
  pdf_document:
    toc: true
    toc_depth: 2
```

You can also customize the size of the figures for the entire document (you will be able to change it for certain chunks with chunk options):

``` {.yaml}
---
output:
  pdf_document:
    fig_width: 7
    fig_height: 6
    fig_caption: true
---
```

Should you choose to do so, you can customize the font size and margins like this:

``` {.yaml}
---
title: "Data Essay"
output: pdf_document
fontsize: 11pt
geometry: "left=3cm,right=3cm,top=2.5cm,bottom=2.5cm"
---
```

Dealing with Unicode character error is a common problem., and it can be avoided with specifying the engine that will generate the PDF document.
By default, PDF documents are rendered using `pdflatex`.
You can specify an alternate engine using the `latex_engine` option.
Available engines are `pdflatex`, `xelatex`, and `lualatex`.
For example:

``` {.yaml}
---
title: "Data Essay"
output:
  pdf_document:
    latex_engine: xelatex
---
```

You can also make your reports a little more flexible and print out the date of knitting rather than the predefined date argument.
This can be done with inline coding in R: `format(Sys.Date(), "%B %d, %Y")` will give date in the format "December 7, 2022".

``` {.yaml}
---
title: "Data Essay"
author: Anna Schmidt
date: `r format(Sys.Date(), "%B %d, %Y")`
output: pdf_document
---
```

> Make sure that if you use this option, the language of your R is the same as the language of the paper your are writing.

If you wish to store the figures your generated in your Rmd separately, you can use R commands to save them.
But you can also set `keep_md: yes` and all the figures you generated will be stored in a new folder `_files`. 

> Make sure to use meaningful chunk labels; otherwise, you will see a bunch of images named `unnamed-chunk-1` and navigating among these files will be harder than it should. 

This works for both PDF and HTML outputs:

``` {.yaml}
---
title: "Data Essay"
output:
  pdf_document:
    keep_md: yes
  html_document:
    keep_md: yes
---
```

Should you ever need to include any additional Latex packages, this is also straightforward:

``` {.yaml}
---
title: "Data Essay"
header-includes:
- \usepackage{dcolumn}
output: pdf_document
---
```

This package ensures that `align=TRUE` argument in `stargazer` works correctly (yet this may still cause problems). If the error with `Missing $ inserted` arises, set `align=FALSE`.

## Chunk Options {.unnumbered}

Here you can find an overview of the most often-used chunk options:

-   `eval`: evaluate the code chunk?
-   `echo`: display the source code in the output document?
-   `include`: include the chunk output in the output document?
-   `results='asis'`: write the raw text results directly into the output document without any markups (essential for `stargazer`)
-   `collapse`: collapse all the source and output blocks from one code chunk into a single block?
-   `warning:` preserve warnings in the output?
-   `error:` preserve errors in the output?
-   `messages:` preserve messages in the output? 

While you can include some default options in the setup chunk inside the `knitr::opts_chunk$set`, you can also specify them directly for every chunk.
For example:

```{r wrap-up-20, eval=FALSE}
knitr::opts_chunk$set(echo = TRUE, 
                      tidy = 'styler' # styles the code in the output
                      )
```

For more on chunk options, please consult <https://yihui.org/knitr/options/>.

## Citations {.unnumbered}

Here we will show you a way to add citations with the Visual Editor mode in Rstudio.
If you'd like to learn a different way to do this, which does not require using Visual Editor mode, please consult our class website: [Doing References in RMarkdown](https://qm-uma.netlify.app/misc/citations/).

### Bibiography in BibTex {.unnumbered .unlisted}

To start with, you will need a file that contains all the bibliographic information about the texts you are using (you can add files there is necessary).
We suggest you use the `bib` format, which is supported by most reference managers.
The `bib` file will have one or many entries like this, one for each article/book/etc.
you add:

    @article{king2000making,
      title={Making the most of statistical analyses: Improving interpretation and presentation},
      author={King, Gary and Tomz, Michael and Wittenberg, Jason},
      journal={American journal of political science},
      pages={347--361},
      year={2000}
    }

There is a unique identifier of the item, `king2000making` in this case, as well as the normal bibliographic information like the title and year of publication.
There are various types of items, like articles or books.

### Step 1: Add (empty) `bib` file {.unnumbered .unlisted}

*If you are already using any reference manager like Zotero or Mendeley, enter the texts you need into the manager as normal and export the `bib` (`Bibtex`) file into the project directory (where your `Rproj` file is located). Here is a way to do it in [Zotero](https://unimelb.libguides.com/latexbibtex/zotero) and in [Mendeley](https://www.imperial.ac.uk/media/imperial-college/administration-and-support-services/library/public/LaTeX-and-Mendeley-apr-2019.pdf).*

If your project does not yet have a file with `bib` extension in your project directory, you can either copy-paste a file like this from any of our lab projects or create a new file with this extension inside Rstudio: *File -\> New File -\> Text File -\> Save as \> "citations.bib" .*

### Step 2: Add Bibliography-related Parameters to YAML in `Rmd` file {.unnumbered .unlisted}

Let's say you now have the `citations.bib` file in the folder of the project folder and your `Rmd` file is located there as well.
Visual Editor will add the correct file name into `bibliography:`, but you will still need to select the style.
In the YAML header, you will need to add the following lines and I want Chicago-style in-text citations:

``` {.md}
bibliography: citations.bib
biblio-style: apsr
```

Style *apsr* is the style used in American Political Science Review, and this is the Chicago author-date style.

In case you need to use a very specific style that is not built-in, it will probably be available here: <https://github.com/citation-style-language/styles>.
Styles are saved in `csl` files, so you will just need to download the file you need, put it in the project folder, and instead of `biblio-style` put `csl` parameter with the name of the respective file.
For instance, if I wanted to use the style of *American Political Science Association*, I would write it like this if saved the `csl` file as `american-political-science-association.csl`:

``` {.md}
bibliography: citations.bib
csl: american-political-science-association.csl
```

### Step 3: Add *References* Section to the Document {.unnumbered .unlisted}

The bibliography is typically placed at the end of the document, so your last heading should be something like `# References`.

### Step 4: Reference Items in the Text {.unnumbered .unlisted}

Now open the Visual Editor mode, and then click on: *Insert -\> Citation* (or just use a shortcut `Ctrl + Shift + F8`/`Cmd + Shift+F8`).
There, you can use the Crossref database and search by title (make sure to select the correct version of the text!) or search by DOI.

Once you found the text, select if you'd like it in format *Author (2000)* or *(Author 2000)* with *Use in-text citation* option and *Insert* the citation.
Your bib entrance will be added to your `bib` file.

Citations go inside square brackets and are separated by semicolons.
Each citation must have a key, composed of '\@' + the citation identifier from the database, and may optionally have a prefix, a locator, and a suffix.
Putting `[]` ensures that there are parenthesis around the citation.

``` {.md}
Blah blah [see @doe99, pp. 33-35; also @smith04, ch. 1].

Blah blah [@smith04; @doe99].
```

A minus sign `-` before the `@` will suppress mention of the author in the citation.
This can be useful when the author is already mentioned in the text and you only need to include the year:

``` {.md}
Smith says blah [-@smith04].
```

This is how you get the in-text citations like *Smith (2004) says blah* and *Smith (2004, 33) says blah*.

``` {.md}
@smith04 says blah

@smith04 [p. 33] says blah
```

Rstudio now also have a nice illustrated guide on the topic: <https://rstudio.github.io/visual-markdown-editing/citations.html>

## Tables and Figures {.unnumbered}

Here is some general advice on how to make a good table and figures:

-   Tables and figures should be clear, easily legible, and quickly understood by the reader

-   Tables and figures should stand alone, and not require the reader to reference the text

-   This requires a table/figure to minimally contain:

    -   A title explaining the material concisely and clearly, with information about the outcome variable of other meaningful quantity of interest described
    -   Information on the sample time period and number of observations included in the graphic
    -   A note or notes that describe clearly what different cell entries or graphed material represents
    -   Meaningful variable names or labels, which clearly indicate meaning
    -   Clear and documented units of measurement
    -   Legends and captions that provide additional information when necessary

Let's look at an example:

```{r reg-results, results='asis', echo=FALSE, out.width="100%"}
stargazer(
  list(m1, m2, m3, m5),
  title = "One-Sided Violence in Armed Conflict, 1989–2004",
  notes = "Standard errors in parenthesis. Excluding observation Rwanda 1994",
  intercept.bottom = TRUE,
  covariate.labels = c(
    "Civil War",
    "Autocracy",
    "Democracy",
    "Polity Score",
    "Polity Score$^{2}$",   #  {} are required for correct knitting in html 
    "Government",
    "One-sided Violence$_{t-1}$",
    "One-sided Violence$_{t-1}\\times$ Autocracy", # \times work only in the PDF output 
    "One-sided Violence$_{t-1}\\times$ Democracy", # when html output is the main one, use * or : instead
    "Constant"
  ),
  dep.var.labels = c("Number killed in one-sided violence"),
  table.placement = "!h", # latex output, keep the figure at exactly Here in text
  type = stargazer_opt,
  header = FALSE # this hides the citation comment
)
```

> Is there anything missing in this table?


# Throwback Wednesday/Thursday/Friday

Remember your first lab exercises?

## Exercise I

*Create three objects:*

1.  `my_lucky_number` it should contain your lucky number
2.  `my_firstname` it should contain your first name
3.  `my_lastname` it should contain your last name

*After you created the objects, call them separately. Don't forget to add comments to your code.*

```{r Exercise-I, eval=FALSE}
# We first create the objects
my_lucky_number <- 
my_firstname <- 
my_lastname <- 

# Now we want to call the objects
my_lucky_number
my_firstname
my_lastname

```

## Exercise II

*Select and recode elements:*

a)  Create two vectors: `vec1` and `vec2`.

    -   `vec1` should contain 1, 56, 23, 89, -3 and 5 (in that order)
    -   `vec2` contains 24, 78, 32, 27, 8 and 1

b)  Now select elements of `vec1` that are greater than 5 or smaller than 0

c)  Next set `vec1` to zero if `vec2` is greater than 30 and smaller or equal to 32

```{r Exercise-II}
```

Remember your first homework?

![Homework 1.1.](images/hw01-1.png) ![Homework 1.2.](images/hw01-2.png)

It took quite some time back then... How long do you think would it take you now?

It's really amazing what you learnt this semester.

So we think you are well prepared to master the Data Essay! 

![Data Essay Marking](images/Marking_blank-1.png)

# References {.unnumbered .unlisted}